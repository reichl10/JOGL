\documentclass[10pt]{scrreprt}
\usepackage[a4paper, top=30mm, left=25mm, right=25mm, bottom=30mm]{geometry}
\usepackage[utf8]{inputenc}

\usepackage[Bjornstrup]{fncychap}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{etoolbox}
\usepackage{enumitem}
\usepackage{url}
\usepackage{numprint}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{multirow}
\usepackage{caption}
\usepackage{array}
\usepackage{listings}
\usepackage{amssymb}


\makeatletter
\patchcmd{\@makechapterhead}{\vspace*{50\p@}}{\vspace*{-20\p@}}{}{}
\patchcmd{\@makeschapterhead}{\vspace*{50\p@}}{\vspace*{7\p@}}{}{}
\patchcmd{\DOTIS}{\vskip 40\p@}{\vskip -12\p@} 
\makeatother
  
\captionsetup[figure]{labelfont={sf,bf},textfont={sf}}
\deffootnotemark{[\thefootnotemark]}
\deffootnote{1.5em}{1em}{[\thefootnotemark] }
\setlength{\parindent}{0pt}
\renewcommand{\labelitemi}{ \raisebox{0.3ex}{\small$\blacktriangleright$} }
\lstset{language=Java}

\newcommand{\sfbf}[1]{\textbf{\sffamily #1}}
\newcommand{\sfit}[1]{\textit{\sffamily #1}}
\newcommand{\W}{\sfbf{W}}
\newcommand{\ziel}[1]{{\fontsize{9.5}{11}\textsf{/#1/}}}
\newcommand{\ziellabel}{Z}
\newcommand{\muss}{\renewcommand{\labelenumi}{\textbf{\ziel{\ziellabel\numprint{\theenumi}0}}}}
\newcommand{\wunsch}{\renewcommand{\labelenumi}{\textbf{\ziel{\ziellabel\numprint{\theenumi}0W}}}}
\newcommand{\JoglEarth}{\raisebox{-1.2mm}{\includegraphics[scale=0.33]{Logo-Text.eps}} }
\newcommand{\textref}[1]{\mbox{\raisebox{0.1ex}{\small$\rightarrow$ }\textit{#1}}}

\newenvironment{details}[1][6pt]{%
  \parskip#1 \parindent6mm \raggedright%
  \def\item{\par\ignorespaces\hangindent=5mm \hangafter1}}{%
  \par\ignorespaces} 
  

\begin{document}

\thispagestyle{empty}
\sffamily
 
\title{Entwurf}

\begin{figure}
\begin{flushright}
	\includegraphics[scale=0.4]{uniLogo.eps}
\vspace{2.0 cm}
\end{flushright}
\end{figure}

\begin{center}
\vspace{2.0 cm}
{\LARGE SEP – Wintersemester 2013/14}

\vspace{1.0 cm}
\textbf{{\Huge Entwurf}}

\vspace{0.8 cm}
\begin{figure}[!htb]
\begin{center}
	%\includegraphics[scale=1.0]{projektLogo.eps}
	\includegraphics[scale=1.5]{Logo-Print.eps}
\end{center}
\end{figure}

\vspace{0.2 cm}
\textbf{{\huge OpenStreetMap: Die Welt in 3D}}

\vspace{1.5 cm}
08.11.2013

\vspace{0.5 cm}
Version: 1.0

\vspace{1.5 cm}
{\Large Projektbetreuer: Peter Barth}

\vspace{1.5 cm}
\begin{tabular}{|c|c|c|}
\hline 
\rule[-1ex]{0pt}{4ex} \textbf{Phase} & \textbf{Verantwortlicher} & \textbf{E-Mail Adresse} \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Pflichtenheft & Gabriele Haas & haasgab@fim.uni-passau.de \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Entwurf & Thomas Eder & ederthom@fim.uni-passau.de \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Spezifikation & Christof Blauberger & blauberg@fim.uni-passau.de \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Implementierung & Fabian Knorr & knorrfab@fim.uni-passau.de \\ 
\hline \hline 
\rule[-1ex]{0pt}{4ex} Testing & Constantin Wenger & wengerco@fim.uni-passau.de \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Präsentation & Sebastian Reichl & reichlse@fim.uni-passau.de \\ 
\hline 
\end{tabular}

\end{center}


\pagebreak
\rmfamily
\tableofcontents

\chapter{Einleitung}

Dieses Dokument stellt den Entwurf von \JoglEarth und der einzelnen Klassen mit deren Interaktion vor.
Die geforderten Funktionalitäten aus dem Pflichtenheft sind abgebildet.
%\textbf{Abweichungen zum Pflichtenheft hier begründen}
\\

Im Zuge der Erstellung dieses Dokuments erfolgte die Planung aller Komponenten mit deren zugehörigen Funktionen. Um das Programm im ganzen zu erfassen finden verschiedene Darstellungsarten Anwendung. \\

Als Überblick wird das Konzept des Programms zu Beginn mithilfe eines Architekturdiagramms erklärt. \\

Der \textit{Rational Software Architect} visualisiert die Interaktionen unter den Komponenten in Form von Diagrammen. Aus den Grafiken gehen einerseits die Vererbungshierachien, andererseits die angewendeten Design Patterns hervor. \\

Der innere Aufbau der Klassen, wie z.B. deren Methoden, wird anhand eines Klassendiagramms verdeutlicht. Wichtige Komponenten sind zusätzlich gesondert herausgearbeitet. \\ 

Um komplexere Zusammenhänge zu veranschaulichen werden detaillierte Auszüge aus der Klassenstruktur entnommen und in einzelne Sequenzdiagramme umgesetzt. Diese erläutern die interne Kommunikation und geben einen Überblick, zu welchem Zeitpunkt im Programmablauf eine oder mehrere Instanzen einer Komponente existiert. \\

Die Priorisierung der im Pflichtenheft angeführten Qualitätsbestimmungen besagt, dass Stabilität, Fehlertoleranz und effizientes Speichermanagement die Hauptmerkmale von \JoglEarth darstellen. Das Code Design wird den Anforderungen der Qualitätskriterien gerecht.\\  

Um dem heutigen Standard hoher Softwarequalität sicherzustellen, fließen im gesamten Entwurfsprozess die gesetzten Gütekriterien und Qualitätsmerkmale ein. 

\chapter{UML-Klassendiagramme}


\begin{figure}[!htb]
\begin{center}
	\includegraphics[scale=1.0]{de_joglearth.eps}
\end{center}
\end{figure}

\newpage

\section{Caching}

\begin{figure}[!htb]
\begin{center}
	\includegraphics[scale=1.0]{de_joglearth_caching.eps}
\end{center}
\end{figure}

\newpage

\section{Geometry}

\begin{figure}[!htb]
\begin{center}
	\includegraphics[scale=0.6]{de_joglearth_geometry.eps}
\end{center}
\end{figure}

\newpage

\section{Rendering}

\begin{figure}[!htb]
\begin{center}
	\includegraphics[scale=0.75]{de_joglearth_rendering.eps}
\end{center}
\end{figure}

\newpage


\section{Settings}

\begin{figure}[!htb]
\begin{center}
	\includegraphics[scale=1.0]{de_joglearth_settings.eps}
\end{center}
\end{figure}

\newpage


\section{Source}

\begin{figure}[!htb]
\begin{center}
	\includegraphics[scale=0.9]{de_joglearth_source.eps}
\end{center}
\end{figure}

\newpage

\section{Surface}

\begin{figure}[!htb]
\begin{center}
	\includegraphics[scale=0.9]{de_joglearth_surface.eps}
\end{center}
\end{figure}

\newpage

\section{UI}

\begin{figure}[!htb]
\begin{center}
	\includegraphics[scale=1.0]{de_joglearth_ui.eps}
\end{center}
\end{figure}


\newpage


\chapter{Beschreibung der Interfaces}

\section{Caching}
\subsection*{Cache}
\begin{lstlisting}
interface Cache<Key, Value>
extends Source<Key, Value>
\end{lstlisting}
Bildet die Basis für einen Cache und implementiert eine Verdrängungsstrategie. Die Speicherung der Daten liegt bei der erbenden Klasse.\\


\vspace{5mm}
\section{Geometry}
\subsection*{Geometry}
\begin{lstlisting}
interface Geometry
\end{lstlisting}
Lorem ipsum\\

\vspace{5mm}
\subsection*{CameraListener}
\begin{lstlisting}
interface CameraListener
\end{lstlisting}
Lorem ipsum\\


\vspace{5mm}
\section{Rendering}
\subsection*{Tessellator}
\begin{lstlisting}
interface Tessellator
\end{lstlisting}
Bietet eine gemeinsame Schnittstelle für das Erzeugen von Kartenkacheln verschiedener Kartenansichten.\\


\vspace{5mm}
\section{Settings}
\subsection*{SettingsListener}
\begin{lstlisting}
interface SettingsListener
\end{lstlisting}
Lorem ipsum\\


\vspace{5mm}
\section{Source}
\subsection*{Source}
\begin{lstlisting}
interface Source<Key, Value>
\end{lstlisting}
Ist in der Lage, über einen \texttt{Key} identifizierte Objekte asynchron zu beschaffen.\\

\vspace{5mm}
\subsection*{SourceListener}
\begin{lstlisting}
interface SourceListener<Key, Value>
\end{lstlisting}
Lorem ipsum\\


\vspace{5mm}
\section{Surface}
\subsection*{SurfaceListener}
\begin{lstlisting}
interface SurfaceListener
\end{lstlisting}
Lorem ipsum\\





\chapter{Klassenbeschreibung}
\section{JoglEarth}
\begin{lstlisting}
final class JoglEarth
\end{lstlisting}
Die Klasse \textit{JoglEarth} implementiert die Main-Methode zum Starten des Programms.\\

\vspace{5mm}
\section{Caching}
\subsection*{CacheBinarySource}
\begin{lstlisting}
class CacheBinarySource<Key>
extends CachedSource<Key, byte[]>
\end{lstlisting}
Erweitert den \textit{CacheSource} um die Möglichkeit den Cache nach Größe statt nach Anzahl der Einträge zu begrenzen.\\

\vspace{5mm}
\subsection*{CachedSource}
\begin{lstlisting}
class CachedSource<Key, Value>
implements Source<Key, Value>
\end{lstlisting}
Lädt Daten aus einer \textit{Source} und verwaltet diese in Caches.\\

\vspace{5mm}
\subsection*{FileSystemCache}
\begin{lstlisting}
class FileSystemCache<Key>
implements Cache<Key, byte[]>
\end{lstlisting}
Der \textit{FileSystemCache} speichert Daten im Dateisystem zwischen.\\

\vspace{5mm}
\subsection*{MemoryCache}
\begin{lstlisting}
class MemoryCache<Key, Value>
implements Cache<Key, Value>
\end{lstlisting}
Der \textit{MemoryCache} speichert Daten im Arbeitsspeicher zwischen.\\

\vspace{5mm}
\subsection*{TextureCache}
\begin{lstlisting}
class TextureCache
extends MemoryCache<Tile, Integer>
\end{lstlisting}
Der \textit{TextureCache} verwaltet die bereits geladene Texturen.\\

 
%% Der \textit{TextureCache} verwaltet in OpenGL geladene Texturen mittels der in der \textit{Cache}-Klasse definierten Verdrängungsstrategie. Er lädt fehlende Texturen aus einer Quelle, wie beispielsweise einem \textit{MemoryCache} für PNG-Dateien, nach, bereitet sie auf und übergibt sie an OpenGL.\\



\vspace{5mm}
\section{Geometry}
\subsection*{Camera}
\begin{lstlisting}
class Camera
\end{lstlisting}
Berechnet die Projektionsmatrix für den Rendervorgang, bestimmt die Sichtbarkeit von 3D-Objekten im Ansichtsfenster und rechnet zwischen Bildschirm- und Raumkoordinaten um.\\

\vspace{5mm}
\subsection*{GeoCoordinates}
\begin{lstlisting}
class GeoCoordinates
implements Cloneable
\end{lstlisting}
Speichert Längen- und Breitengrad von einem Punkt.\\

\vspace{5mm}
\subsection*{Matrix4}
\begin{lstlisting}
class Matrix4
implements Cloneable
\end{lstlisting}
Hält eine 4x4-Matrix, die Operationen zum Rotieren, Verschieben und Skalieren, sowie eine Funktion zum transformieren eines 4-dimensionalen Vektors anbietet. Die Klasse wird zum Bestimmen der Projektionsmatrix in der Kamera und der Sichtbarkeit von Objekten verwendet.\\

\vspace{5mm}
\subsection*{PlaneGeometry}
\begin{lstlisting}
class PlaneGeometry
implements Geometry
\end{lstlisting}
Implementiert das \textit{Geometry}-Interface für räumliche Berechnungen auf einer Ebene.\\

\vspace{5mm}
\subsection*{ScreenCoordinates}
\begin{lstlisting}
class ScreenCoordinates
implements Cloneable
\end{lstlisting}
Stellt den Punkt anhand der Bildschirmkoordinaten dar.\\

\vspace{5mm}
\subsection*{SphereGeometry}
\begin{lstlisting}
class SphereGeometry
implements Geometry
\end{lstlisting}
Implementiert das \textit{Geometry}-Interface für räumliche Berechnungen auf der Kugeloberfläche.\\

\vspace{5mm}
\subsection*{Tile}
\begin{lstlisting}
class Tile 
implements Cloneable
\end{lstlisting}
Speichert Längen- und Breitengradgrenzen sowie das Zoomlevel, über das sich eine Kartenkachel nach dem OpenStreetMap-Format identifizieren lässt.\\

\vspace{5mm}
\subsection*{Vector3}
\begin{lstlisting}
class Vector3
implements Cloneable
\end{lstlisting}
Ein 3-dimensionaler Vektor. Repräsentiert üblicherweise Raumkoordinaten.\\

\vspace{5mm}
\subsection*{Vector4}
\begin{lstlisting}
class Vector4
implements Cloneable
\end{lstlisting}
Ein 4-dimensionaler Vektor für homogene Koordinaten. Instanzen dieser Klasse werden benötigt, wenn zwischen 3D-Perspektiven umgerechnet werden soll.\\





\vspace{5mm}
\section{Rendering}
\subsection*{Mesh}
\begin{lstlisting}
class Mesh
\end{lstlisting}
Speichert Rohdaten eines 3D-Modells wie seine Vertices, Normalen, und Texturkoordinaten. Kann vom \textit{Renderer} an OpenGL übergeben werden.\\

\vspace{5mm}
\subsection*{PlaneTessellator}
\begin{lstlisting}
class PlaneTessellator
implements Tessellator
\end{lstlisting}
Generiert Kartenkacheln in der Ebene.\\

\vspace{5mm}
\subsection*{Renderer}
\begin{lstlisting}
class Renderer
implements SourceListener<Tile, Integer>, Runnable, CameraListener, SettingsListener
\end{lstlisting}
Ist für das Zeichnen einzelner Frames und die zeitliche Steuerung während Animationen verantwortlich. Rendert entweder Einzelbilder als Reaktion auf eine Aktualisierung über den \textit{SourceListener}, \textit{CameraListener} oder \textit{SettingsListener} oder eine kontinuierliche Bildfolge während Animationsvorgängen.\\
%\textit{SurfaceListener} nötig?

\vspace{5mm}
\subsection*{SphereTessellator}
\begin{lstlisting}
class SphereTessellator
implements Tessellator
\end{lstlisting}
Generiert Kartenkacheln auf der Kugeloberfläche.\\




\vspace{5mm}
\section{Settings}
\subsection*{Settings}
\begin{lstlisting}
class Settings
\end{lstlisting}
Verwaltet alle erforderlichen Einstellungen sowie die vom Benutzer markierten Punkte aus der Datei \texttt{settings.xml}. Die Einstellungen werden gekapselt und anderen Klassen zugänglich gemacht, außerdem können sich andere Klassen als Beobachter (\textit{Observer}) registrieren um über Einstellungsänderungen benachrichtigt zu werden.\\

\subsection*{SettingsContract}
\begin{lstlisting}
final class SettingsContract
\end{lstlisting}
Speichern und laden von Settings. Verwaltet die IDs der verschiedenen Settings.\\



\vspace{5mm}
\section{Source}
\subsection*{HTTPUtils}
\begin{lstlisting}
final class HTTPUtils
\end{lstlisting}
Stellt statische Funktionen für einfache GET- und POST- Abfragen via HTTP zur Verfügung.\\

\vspace{5mm}
\subsection*{NominatimQuery}
\begin{lstlisting}
class NominatimQuery
\end{lstlisting}
Drückt eine Suchanfrage an Nominatim aus. Dies kann die Suche nach Details zu einem bestimmten Punkt oder nach einem Ort sein.\\

\vspace{5mm}
\subsection*{NominatimSource}
\begin{lstlisting}
class NominatimSource
implements Source<NominatimQuery, Location[]>
\end{lstlisting}
\textit{NominatimSource} beschafft Antworten auf Suchanfragen nach Orten und Punktinformationen (\textit{NominatemQuery}) und bereitet sie für den \textit{LocationManager} auf. Dabei greift sie auf \textit{HTTPUtils} zu.\\

\vspace{5mm}
\subsection*{OSMTileSource}
\begin{lstlisting}
class OSMTileSource
implements Source<Tile, byte[]>
\end{lstlisting}
Die \textit{OSMTileSource} lädt anhand von Koordinaten (u. U. komprimierte) Kacheltexturen per HTTP von OpenStreetMap-Servern. Dabei macht sie von \textit{HTTPUtils} Gebrauch.\\

\vspace{5mm}
\subsection*{OverpassQuery}
\begin{lstlisting}
class OverpassQuery
\end{lstlisting}
Drückt eine Suchanfrage an die OverpassAPI aus. Eine solche Suche liefert für gewöhnlich POIs und Städtenamen im Sichtfeld zurück. Die Anfrage enthält dazu die zu durchsuchende Umgebung.\\

\vspace{5mm}
\subsection*{OverpassSource}
\begin{lstlisting}
class OverpassSource
implements Source<OverpassQuery, Location[]>
\end{lstlisting}
\textit{OverpassSource} beschafft die Details lokaler POIs und Städtenamen (\textit{OverpassQuery}) und bereitet sie für die Verwaltung durch den \textit{LocationManager} vor.\\

\vspace{5mm}
\subsection*{SourceResponse}
\begin{lstlisting}
class SourceResponse<Value>
\end{lstlisting}
Rückgabetyp der \textit{Source} inkl. Informationen über die Art der Nachlieferung.\\

\vspace{5mm}
\subsection*{SRTMTileSource}
\begin{lstlisting}
class SRTMTileSource
implements Source<Tile, byte[]>
\end{lstlisting}
Die \textit{SRTMTileSource} lädt anhand von Indizes Höhenprofil-Kacheln von NASA-SRTM-Servern. Dabei macht sie von \textit{HTTPUtils} Gebrauch.\\

\vspace{5mm}
\subsection*{TextureSource}
\begin{lstlisting}
class TextureSource
implements Source<Tile, Integer>
\end{lstlisting}
Lädt die Texturen in OpenGL.\\





\vspace{5mm}
\section{Surface}
\subsection*{HeightMapManager}
\begin{lstlisting}
class HeightMapManager
implements SettingsListener
\end{lstlisting}
Interpoliert Höheninformationen für Punkte der Karte aus SRTM-Höhendaten. Wird von \textit{Tessellator}en verwendet, um Kartenoberflächen mit dem Höhenprofil zu generieren.\\

\vspace{5mm}
\subsection*{Location}
\begin{lstlisting}
class Location
implements Cloneable
\end{lstlisting}
Speichert Längen- und Breitengradkoordinaten mit Details zu einem Punkt ab. Wird vom \textit{LocationManager} benutzt, um alle Arten von Punkten auf der Karte zu verwalten.\\

\vspace{5mm}
\subsection*{LocationManager}
\begin{lstlisting}
class LocationManager
implements SettingsListener
\end{lstlisting}
Verwaltet die Sichtbarkeit von besonderen Punkten im Ansichtsfenster und der GUI. Er besorgt außerdem Suchergebnisse über den \textit{NominatimSource} und Benutzermarkierungen aus den \textit{Settings}.\\

\vspace{5mm}
\subsection*{SurfaceNotifier}
\begin{lstlisting}
class SurfaceNotifier
implements SurfaceListener
\end{lstlisting}
Lorem ipsum\\

\vspace{5mm}
\subsection*{TextureManager}
\begin{lstlisting}
class TextureManager
\end{lstlisting}
Bearbeitet Texturanfrage vom \textit{Renderer}. Lädt die Texturen aus einer \textit{CachedSource} die auf einem \textit{TextureSource} und einem \textit{TextureCache} zurückgreift.\\




\vspace{5mm}
\section{UI}
\subsection*{GUI}
\begin{lstlisting}
class GUI
extends JFrame
implements SurfaceListener, CameraListener, SettingsListener
\end{lstlisting}
Die Klasse \textit{GUI} erbt von JFrame und stellt die gesamte grafische Bedienoberfläche dar. Pro Sitzung darf lediglich eine Instanz der \textit{GUI} existieren.\\

\vspace{5mm}
\subsection*{GUIEventListener}
\begin{lstlisting}
class GUIEventListener
\end{lstlisting}
Reagiert auf Ereignisse der Swing-Elemente der GUI; d.h. auf alle Benutzereingaben die außerhalb des Ansichtsfensters stattfinden. Verändert unter Umständen Werte von \textit{Settings} oder gibt Ereignisse an den Renderer oder andere Komponenten über den \textit{UpdateListener}-Mechanismus weiter.\\

\vspace{5mm}
\subsection*{ViewEventListener}
\begin{lstlisting}
class ViewEventListener
implements /* zum Beispiel */ MouseWheelListener, MouseListener, MouseMotionListener
\end{lstlisting}
Reagiert auf Benutzereingaben im Ansichtsfenster wie Tastendrücke, Scrollen und Ziehen mit der Maus. Die Klasse benachrichtigt andere Komponenten, wie die \textit{Camera}, über Veränderungen der Ansicht.\\






\chapter{Beschreibung der Enumerations}
\section{Source}

\subsection*{NominatimQuery.Type}
\begin{tabular}{|c|l|}
\hline
\textit{GLOBAL} & Globale Suche nach Punkten \\
\hline
\textit{LOCAL} & Suche nach Punkten im Sichtbereich \\
\hline
\textit{POINT} & Alle verfügbaren Informationen zu einem bestimmten Punkt \\
\hline
\end{tabular}




\subsection*{OSMTileType}
z.B. 	day  |  night
Unterscheidung der verschiedenen Kartenmaterialien.


\subsection*{SourceResponseType}
asynchronous  | missing | synchronous



\section{Surface}
\subsection*{LocationType}
POIs usw.
Unterscheidung beispielsweise der Städtenamen von markierten Punkten.








\chapter{Sequenzdiagramme}

\section{Laden einer lokal noch nicht vorhandenen Kachel}
In diesem Sequenzdiagramm wird dargestellt, wie die Anfrage nach einer Texturkachel über die verschiedenen Cacheebenen propagiert und schließlich asynchron beantwortet wird.\\


\begin{figure}
\begin{centering}
\includegraphics[scale=0.57,angle=90,origin=c]{Ablaufdiagramm.eps}
\caption{Laden einer lokal noch nicht vorhandenen Kachel}
\end{centering}
\end{figure}




\chapter{Designpatterns}
\section{Adapter Pattern}
Das \textit{Adapter Pattern} ist ein Strukturmuster. \\
Es dient zur Übersetzung einer Schnittstelle in eine andere. \\ Dieses Pattern findet Anwendung bei den \textit{Mouse- und Key"-listenern}, welche in der Benutzeroberfläche implementiert werden. \\ Ziel ist es den Quellcode übersichtlich zu halten. Aus diesem Grund werden nur die benötigten Methoden der Listener überschrieben. Alle nicht erforderlichen Methoden werden ignoriert.

\section{Chain of Responsibility Pattern}
Das \textit{Chain of Responsibility Pattern} (bzw. Zuständigkeitskette) ist ein Verhaltensmuster. \\
Hierbei werden mehrere Objekte hintereinander verkettet um gemeinsam eine eingehende Anfrage bearbeiten zu können. Dafür wird eine Anfrage entlang der Kette durchgereicht, bis ein Objekt die Anfrage beantworten kann. \\ Es findet Anwendung beim Speichermanagement. Eine Anfrage für eine benötigte Ressource wird immer an den \textit{memoryCache} gestellt. Die Anfrage wird entsprechend der Kette (siehe Abbildung) durchgereicht bis sie bearbeitet werden kann. \\ Ziel ist  die Entkopplung des Auslösers einer Anfrage mit seinem Empfänger.

\section{Data Transfer Object}
Das \textit{Data Transfer Object} ist ein Muster für objektrelationale Abbildung. \\
Hierbei werden mehrere Daten gebündelt als ein Objekt übertragen. \\ Es findet Anwendung bei Suchergebnissen und der Anfrage nach POIs. Alle Datensätze werden dann gebündelt übergeben und nicht jede Information seperat. \\ Ziel ist es die Daten zu strukturieren bzw. vollständig gruppierte Information zu einer Anfrage zu erhalten.

\section{Iterator Pattern}
Das \textit{Iterator Pattern} ist ein Verhaltensmuster. \\ Hierbei wird die verwendete Datenstruktur elementweise durchlaufen, ohne deren interne Anordnung preiszugeben.\\ %Es findet Anwendung ... \\
Ziel ist es die eingesetzten Datenstrukturen effizient zu durchsuchen.

\newpage
\section{Mediator Pattern}
Das \textit{Mediator Pattern} ist ein Verhaltensmuster. \\ Hierbei fungiert der Vermittler als Kommunikationsschnittstelle zwischen Objekten in einem komplexen System. \\ Es findet mehrfache Anwendung im gesamten Programm, wie beispielsweise beim Speichermanagement, beim Rendering, usw. \\ Ziel ist lockere Kopplung. Es sollen nicht alle Objekt voneinander Kenntnis besitzen.

\section{Model-View-Controller (MVC) Pattern}
Das \textit{Model-View-Controller Pattern} ist ein Architekturmuster. \\
\begin{figure}[ht]
\begin{centering}
\includegraphics[scale=0.5]{ModelViewController.eps}
\caption{Das Model-View-Controller Pattern}
\end{centering}
\end{figure}



\section{Multiton Pattern}
Das \textit{Multiton Pattern} ist ein Erzeugungsmuster. \\ Hierbei wird sichergestellt, dass mehrere Instanzen eines Objekts existieren dürfen. Eine eindeutige Zuordnung wird geregelt durch Vergabe eines Schlüssels. \\ 
% Es findet Anwendung bei den \textit{RequestListenern} ???? \\ 
Ziel ist parallele Anfragestellung und -beantwortung.

\section{Observer Pattern}
Das \textit{Observer Pattern} ist ein Verhaltensmuster. \\ Hierbei wird eine Info bei durchgeführten Änderungen am Objekt an alle abhängigen Komponenten weitergegeben. \\ % Es findet Anwendung ... jede Menge Observer \\ 
Ziel ist lose Kopplung und zudem werden die abhängigen Objekte automatisch über Änderungen in Kenntnis gesetzt.

\section{Singleton Pattern}
Das \textit{Singleton Pattern} ist ein Erzeugungsmuster. \\ Hierbei wird sichergestellt, dass genau eine einzige Instanz eines Objekts existiert. \\ Es findet Anwendung bei der Benutzeroberfläche, von der nur eine Instanz existieren darf. \\ Ziel ist eine sichergestellte Zugriffskontrolle auf das Objekt. 




\chapter{Qualitätsmerkmale}
\section{Entwurfsqualität}
Bei der Qualität des Entwurfs beziehen wir uns auf \textit{Robert Cecil Martins} Merkmalsdefinitionen \footnote{Robert Cecil Martin (2002). Agile Software Development: Principles, Patterns and Practices. Pearson Education.} die im Folgenden erläutert werden.

\subsection*{Anzahl an Klassen und Interfaces}
Die Anzahl aller Klassen inklusive abstrakter Klassen (sowie Interfaces) im gesamten Paket. Es dient als aussagekräftiger Indikator für die Erweiterbarkeit eines Pakets.

\subsection*{Afferente Kopplung}
Die Abhängigkeit anderer Pakete von einem Paket ist ein Maß für dessen Verantwortlichkeiten und dessen Einfluss.

\subsection*{Efferente Kopplung}
Die Abhängigkeit eines Pakets von anderen Paketen ist ein Maß für die Unselbstständigkeit dieses Pakets.

\subsection*{Abstraktheit}
Der Anteil abstrakter Klassen (sowie Interfaces) an allen Klassen im Paket ist ein Indikator für die Abstraktheit eines Pakets.

\subsection*{Stabilität}
Das Verhältnis von afferenter Kopplung zur gesamten Kopplung gibt Auskunft über die Resilienz gegenüber Änderungen eines Pakets.

\subsection*{Balance von Abstraktion und Abhängigkeit}
Der Abstraktionsgrad der Klassen sollte in etwa deren Unabhängigkeit von anderen Klassen entsprechen. Bei Erfüllung der Anforderung spricht man von optimaler Balance.

\subsection*{Kohäsion}
Als Ergänzung zu Martin's Definitionen, welche sich nur auf das Zusammenspiel zwischen den Paketen bezieht, wird zudem die Kohäsion berücksichtigt.\\

Kohäsion ist der Versuch, zusammenhängende Programmstrukturen in einer Klasse zusammenzuführen, um z.B. nachträgliche Änderungen auf lokale Anpassungen des Codes zu beschränken.


\section{Gütekriterien nach ISO/IEC 9126}
\subsection*{Funktionalität}
Funktionalität beinhaltet Angemessenheit, Richtigkeit, Interoperabilität, Ordnungsmäßigkeit und Sicherheit.

\subsection*{Zuverlässigkeit}
Eine Menge von Merkmalen, die sich auf die Fähigkeit einer Software/eines Systems beziehen, ihr/sein Leistungsniveau unter festgelegten Bedingungen über einen festgelegten Zeitraum oder über eine festgelegte Anzahl von Transaktionen zu bewahren. [ISO 9126]

\subsection*{Benutzbarkeit}
Die Fähigkeit eines Softwareprodukts, unter spezifizierten Bedingungen für einen Benutzer verständlich, erlernbar, anwendbar und attraktiv zu sein. [ISO 9126]

\subsection*{Effizienz}
(1) Die Fähigkeit eines Softwareprodukts, unter festgelegten Bedingungen eine angemessene Leistung zu erbringen, bezogen auf den Umfang der eingesetzten Betriebsmittel. [ISO 9126]

\subsection*{Änderbarkeit}
Mit Änderbarkeit bezeichnet man den Aufwand, der zur Durchführung bestimmter Änderungen notwendig ist. Änderungen können Korrekturen, Verbesserungen oder Anpassungen an Änderungen der Umgebung, der Anforderungen und der funktionalen Spezifikation einschließen. [ISO 9126]

\subsection*{Portabilität}
Portabilität oder Übertragbarkeit ist die Eignung einer Software, von einer Umgebung in eine andere übertragen zu werden. Diese Umgebung kann die organisatorische Umgebung, Hardware- oder Software-Umgebung einschließen. [ISO 9126]


\end {document}