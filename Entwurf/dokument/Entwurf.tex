\documentclass[10pt]{scrreprt}
\usepackage[a4paper, top=30mm, left=25mm, right=25mm, bottom=30mm]{geometry}
\usepackage[utf8]{inputenc}

\usepackage[Bjornstrup]{fncychap}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{etoolbox}
\usepackage{enumitem}
\usepackage{url}
\usepackage{numprint}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{multirow}
\usepackage{caption}
\usepackage{array}
\usepackage{listings}
\usepackage{amssymb}


\makeatletter
\patchcmd{\@makechapterhead}{\vspace*{50\p@}}{\vspace*{-20\p@}}{}{}
\patchcmd{\@makeschapterhead}{\vspace*{50\p@}}{\vspace*{7\p@}}{}{}
\patchcmd{\DOTIS}{\vskip 40\p@}{\vskip -12\p@} 
\makeatother
  
\captionsetup[figure]{labelfont={sf,bf},textfont={sf}}
\deffootnotemark{[\thefootnotemark]}
\deffootnote{1.5em}{1em}{[\thefootnotemark] }
\setlength{\parindent}{0pt}
\renewcommand{\labelitemi}{ \raisebox{0.3ex}{\small$\blacktriangleright$} }
\lstset{language=Java}

\newcommand{\sfbf}[1]{\textbf{\sffamily #1}}
\newcommand{\sfit}[1]{\textit{\sffamily #1}}
\newcommand{\W}{\sfbf{W}}
\newcommand{\ziel}[1]{{\fontsize{9.5}{11}\textsf{/#1/}}}
\newcommand{\ziellabel}{Z}
\newcommand{\muss}{\renewcommand{\labelenumi}{\textbf{\ziel{\ziellabel\numprint{\theenumi}0}}}}
\newcommand{\wunsch}{\renewcommand{\labelenumi}{\textbf{\ziel{\ziellabel\numprint{\theenumi}0W}}}}
\newcommand{\JoglEarth}{\raisebox{-1.2mm}{\includegraphics[scale=0.33]{Logo-Text.eps}} }
\newcommand{\textref}[1]{\mbox{\raisebox{0.1ex}{\small$\rightarrow$ }\textit{#1}}}

\newenvironment{details}[1][6pt]{%
  \parskip#1 \parindent6mm \raggedright%
  \def\item{\par\ignorespaces\hangindent=5mm \hangafter1}}{%
  \par\ignorespaces} 
  

\begin{document}

\thispagestyle{empty}
\sffamily
 
\title{Entwurf}

\begin{figure}
\begin{flushright}
	\includegraphics[scale=0.4]{uniLogo.eps}
\vspace{2.0 cm}
\end{flushright}
\end{figure}

\begin{center}
\vspace{2.0 cm}
{\LARGE SEP – Wintersemester 2013/14}

\vspace{1.0 cm}
\textbf{{\Huge Entwurf}}

\vspace{0.8 cm}
\begin{figure}[!htb]
\begin{center}
	%\includegraphics[scale=1.0]{projektLogo.eps}
	\includegraphics[scale=1.5]{Logo-Print.eps}
\end{center}
\end{figure}

\vspace{0.2 cm}
\textbf{{\huge OpenStreetMap: Die Welt in 3D}}

\vspace{1.5 cm}
08.11.2013

\vspace{0.5 cm}
Version: 1.0

\vspace{1.5 cm}
{\Large Projektbetreuer: Peter Barth}

\vspace{1.5 cm}
\begin{tabular}{|c|c|c|}
\hline 
\rule[-1ex]{0pt}{4ex} \textbf{Phase} & \textbf{Verantwortlicher} & \textbf{E-Mail Adresse} \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Pflichtenheft & Gabriele Haas & haasgab@fim.uni-passau.de \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Entwurf & Thomas Eder & ederthom@fim.uni-passau.de \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Spezifikation & Christof Blauberger & blauberg@fim.uni-passau.de \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Implementierung & Fabian Knorr & knorrfab@fim.uni-passau.de \\ 
\hline \hline 
\rule[-1ex]{0pt}{4ex} Testing & Constantin Wenger & wengerco@fim.uni-passau.de \\ 
\hline  \hline
\rule[-1ex]{0pt}{4ex} Präsentation & Sebastian Reichl & reichlse@fim.uni-passau.de \\ 
\hline 
\end{tabular}

\end{center}


\pagebreak
\rmfamily
\tableofcontents

\chapter{Einleitung}

Dieses Dokument stellt den Entwurf von \JoglEarth und der einzelnen Klassen mit deren Interaktion vor.
Die geforderten Funktionalitäten aus dem Pflichtenheft sind abgebildet.
\textbf{Abweichungen zum Pflichtenheft hier begründen}
\\

Im Zuge der Erstellung dieses Dokuments erfolgte die Planung aller Komponenten mit deren zugehörigen Funktionen. Um das Programm im ganzen zu erfassen finden verschiedene Darstellungsarten Anwendung. \\

Als Überblick wird das Konzept des Programms zu Beginn mithilfe eines Architekturdiagramms erklärt. \\

Der \textit{Rational Software Architect} visualisiert die Interaktionen unter den Komponenten in Form von Diagrammen. Aus den Grafiken gehen einerseits die Vererbungshierachien, andererseits die angewendeten Design Patterns hervor. \\

Der innere Aufbau der Klassen, wie z.B. deren Methoden, wird anhand eines Klassendiagramms verdeutlicht. Wichtige Komponenten sind zusätzlich gesondert herausgearbeitet. \\ 

Um komplexere Zusammenhänge zu veranschaulichen werden detaillierte Auszüge aus der Klassenstruktur entnommen und in einzelne Sequenzdiagramme umgesetzt. Diese erläutern die interne Kommunikation und geben einen Überblick, zu welchem Zeitpunkt im Programmablauf eine oder mehrere Instanzen einer Komponente existiert. \\

Die Priorisierung der im Pflichtenheft angeführten Qualitätsbestimmungen besagt, dass Stabilität, Fehlertoleranz und effizientes Speichermanagement die Hauptmerkmale von \JoglEarth darstellen. Das Code Design wird den Anforderungen der Qualitätskriterien gerecht.\\  

Um dem heutigen Standard hoher Softwarequalität sicherzustellen, fließen im gesamten Entwurfsprozess die gesetzten Gütekriterien und Qualitätsmerkmale ein. 

\chapter{UML-Klassendiragramme}

\section{Package Model}
\begin{figure}[!htb]
	\includegraphics[scale=0.5]{JoglDiagramm_Model.eps}
\vspace{2.0 cm}
\end{figure}

\section{Package View}
\begin{figure}[!htb]
	\includegraphics[scale=0.7]{JoglDiagramm_View.eps}
\vspace{2.0 cm}
\end{figure}

\section{Package Controller}
\begin{figure}[!htb]
	\includegraphics[scale=0.5]{JoglDiagramm_Controller.eps}
\vspace{2.0 cm}
\end{figure}

\chapter{Klassenbeschreibung}

\section{Package Model}


\subsection*{HTTPUtils}
\begin{lstlisting}
final class HTTPUtils
\end{lstlisting}
Stellt statische Funktionen für einfache GET- und POST- Abfragen via HTTP zur Verfügung.\\

\subsection*{Source}
\begin{lstlisting}
abstract class Source<Key, Value>
implements RequestListener<Key, Value>
\end{lstlisting}
Ist in der Lage, über einen \texttt{Key} identifizierte Objekte asynchron zu beschaffen.
\\


\subsection*{Cache}
\begin{lstlisting}
abstract class Cache<Key, Value> 
extends Source<Key, Value>
implements RequestListener<Key, Value>
\end{lstlisting}
Bildet die Basis für einen Cache und implementiert eine Verdrängungsstrategie. Die Speicherung der Daten liegt bei der erbenden Klasse.
\\

\subsection*{TextureCache}
\begin{lstlisting}
class TextureCache<Key>
extends Cache<Key, Integer>
\end{lstlisting}
Der \textit{TextureCache} verwaltet in OpenGL geladene Texturen mittels der in der \textit{Cache}-Klasse definierten Verdrängungsstrategie. Er lädt fehlende Texturen aus einer Quelle, wie beispielsweise einem \textit{MemoryCache} für PNG-Dateien, nach, bereitet sie auf und übergibt sie an OpenGL. 
\\

\subsection*{MemoryCache}
\begin{lstlisting}
class MemoryCache<Key, Value>
extends Cache<Key, Value>
\end{lstlisting}
Der \textit{MemoryCache} verwaltet einen Zwischenspeicher im RAM. Zudem besitzt er Kenntnis über einen sekundären Cache (beispielsweise einen \textit{FileSystemCache}) und eine Datenquelle, die bei Bedarf angefragt werden können.
\\

\subsection*{FileSystemCache}
\begin{lstlisting}
class FileSystemCache<Key, Value>
extends Cache<Key, Value>
\end{lstlisting}
Der \textit{FileSystemCache} speichert Daten im Dateisystem zwischen.
\\

\subsection*{OSMTileSource}
\begin{lstlisting}
class OSMTileSource
extends Source<Tile, byte[]>
\end{lstlisting}
Die \textit{OSMTileSource} lädt anhand von Koordinaten (u.U. komprimierte) Kacheltexturen per HTTP von OpenStreetMap-Servern. Dabei macht sie von \textit{HTTPUtils} Gebrauch.\\

\subsection*{SRTMTileSource}
\begin{lstlisting}
class SRTMTileSource extends
Source<Tile, byte[]>
\end{lstlisting}
Die \textit{OSMTileSource} lädt anhand von Indizes Höhenprofil-Kacheln von NASA-SRTM-Servern. Dabei macht sie von \textit{HTTPUtils} Gebrauch.\\

\subsection*{NominatimSource}
\begin{lstlisting}
class NominatimSource
extends Source<NominatimQuery, Location[]>
\end{lstlisting}
\textit{NominatimSource} beschafft Antworten auf Suchanfragen nach Orten und Punktinformationen (\textit{NominatemQuery}) und bereitet sie für den \textit{LocationManager} auf. Dabei greift sie auf \textit{HTTPUtils} zu.\\

\subsection*{OverpassSource}
\begin{lstlisting}
class OverpassSource
extends Source<OverpassQuery, Location[]>
\end{lstlisting}
\textit{OverpassSource} beschafft die Details lokaler POIs und Städtenamen (\textit{OverpassQuery}) und bereitet sie für die Verwaltung durch den \textit{LocationManager} vor.\\

\subsection*{NominatimQuery}
\begin{lstlisting}
class NominatimQuery
\end{lstlisting}
Drückt eine Suchanfrage an Nominatim aus. Dies kann die Suche nach Details zu einem bestimmten Punkt oder nach einem Ort sein.\\

\subsection*{OverpassQuery}
\begin{lstlisting}
class OverpassQuery
\end{lstlisting}
Drückt eine Suchanfrage an die OverpassAPI aus. Eine solche Suche liefert für gewöhnlich POIs und Städtenamen im Sichtfeld zurück, die Anfrage enthält dazu die zu durchsuchende Umgebung.\\

\subsection*{Settings}
\begin{lstlisting}
class Settings 
extends UpdateProvider
\end{lstlisting}
Verwaltet alle erforderlichen Einstellungen sowie die vom Benutzer markierten Punkte aus der Datei \texttt{settings.xml}. Die Einstellungen werden gekapselt und anderen Klassen zugänglich gemacht, außerdem können sich andere Klassen als Beobachter (\textit{Observer}) registrieren um über Einstellungsänderungen benachrichtigt zu werden.\\



\section{Package View}
\subsection*{GUI}
\begin{lstlisting}
class GUI 
extends JFrame 
implements UpdateListener
\end{lstlisting}
Die Klasse \textit{GUI} erbt von JFrame und stellt die gesamte grafische Bedienoberfläche dar. Pro Sitzung darf lediglich eine Instanz der \textit{GUI} existieren.\\

\subsection*{GUIEventListener}
\begin{lstlisting}
class GUIEventListener
extends UpdateProvider
\end{lstlisting}
Reagiert auf Ereignisse der Swing-Elemente der GUI; d.h. auf alle Benutzereingaben die außerhalb des Ansichtsfensters stattfinden. Verändert unter Umständen Werte von \textit{Settings} oder gibt Ereignisse an den Renderer oder andere Komponenten über den \textit{UpdateListener}-Mechanismus weiter.\\

\subsection*{ViewEventListener}
\begin{lstlisting}
class ViewEventListener
extends UpdateProvider 
implements MouseWheelListener, MouseListener, MouseMotionListener
\end{lstlisting}
Reagiert auf Benutzereingaben im Ansichtsfenster wie Tastendrücke, Scrollen und Ziehen mit der Maus. Die Klasse benachrichtigt andere Komponenten, wie die \textit{Camera}, über Veränderungen der Ansicht. \\

\subsection*{Renderer}
\begin{lstlisting}
class Renderer
implements RequestListener<Tile, Integer>, Runnable, UpdateListener
\end{lstlisting}
Ist für das Zeichnen einzelner Frames und die zeitliche Steuerung während Animationen verantwortlich. Sie rendert entweder Einzelbilder als Reaktion auf eine Aktualisierung über den \textit{UpdateListener}-Mechanismus, oder eine kontinuierliche Bildfolge während Animationsvorgängen.\\

\subsection*{Mesh}
\begin{lstlisting}
class Mesh
\end{lstlisting}
Speichert Rohdaten eines 3D-Modells wie seine Vertices, Normalen, und Texturkoordinaten. Kann vom \textit{Renderer} an OpenGL übergeben werden.\\

\subsection*{Tessellator}
\begin{lstlisting}
interface Tessellator
\end{lstlisting}
Bietet eine gemeinsame Schnittstelle für das Erzeugen von Kartenkacheln verschiedener Kartenansichten.\\

\subsection*{PlaneTessellator}
\begin{lstlisting}
class PlaneTessellator
implements Tessellator
\end{lstlisting}
Generiert Kartenkacheln in der Ebene.\\

\subsection*{SphereTessellator}
\begin{lstlisting}
class SphereTessellator
implements Tessellator
\end{lstlisting}
Generiert Kartenkacheln auf der Kugeloberfläche.\\




\section{Package Controller}
\subsection*{Camera}
\begin{lstlisting}
class Camera
\end{lstlisting}
Berechnet die Projektionsmatrix für den Rendervorgang, bestimmt die Sichtbarkeit von 3D-Objekten im Ansichtsfenster und rechnet zwischen Bildschirm- und Raumkoordinaten um.\\


\subsection*{HeightMap}
\begin{lstlisting}
class HeightMap
extends UpdateProvide
\end{lstlisting}
Interpoliert Höheninformationen für Punkte der Karte aus SRTM-Höhendaten. Wird von \textit{Tessellator}en verwendet, um Kartenoberflächen mit Höhenprofil zu generieren.\\



\subsection*{UpdateListener}
\begin{lstlisting}
interface UpdateListener
\end{lstlisting}
Interface für Objekte, die Nachrichten über den \textit{UpdateListener}-Mechanismus entgegennehmen können.\\


\subsection*{UpdateProvider}
\begin{lstlisting}
class UpdateProvider
\end{lstlisting}
Basisklasse für Objekte, die über den \textit{UpdateListener}-Mechanismus Nachrichten verteilen.\\



\subsection*{Location}
\begin{lstlisting}
class Location
\end{lstlisting}
Speichert Länden- und Breitengradkoordinaten mit Details zu einem Punkt ab. Wird vom \textit{LocationManager} benutzt, um alle Arten von Punkten auf der Karte zu verwalten. \\



\subsection*{LocationManager}
\begin{lstlisting}
class LocationManager
extends UpdateProvider
implements UpdateListener
\end{lstlisting}
Verwaltet die Sichtbarkeit von besonderen Punkten im Ansichtsfenster und der GUI. Er besorgt außerdem Suchergebnisse über den \textit{NominatimCache} und Benutzermarkierungen aus den \textit{Settings}.\\



\subsection*{Tile}
\begin{lstlisting}
class Tile
\end{lstlisting}
Speichert Längen- und Breitengradgrenzen sowie das Zoomlevel, über das sich eine Kartenkachel nach dem OpenStreetMap-Format identifizieren lässt.\\


\subsection*{Point}
\begin{lstlisting}
class Point
\end{lstlisting}
Beschreibt einen zweidimensionalen reellen Vektor.\\


\subsection*{Matrix4}
\begin{lstlisting}
class Matrix4
implements Cloneable
\end{lstlisting}
Hält eine 4x4-Matrix, die Operationen zum Rotieren, Verschieben und Skalieren, sowie eine Funktion zum transformieren eines 4-dimensionalen Vektors anbietet. Die Klasse wird zum Bestimmen der Projektionsmatrix in der Kamera und der Sichtbarkeit von Objekten verwendet.\\



\subsection*{Vector3}
\begin{lstlisting}
class Vector3
implements Cloneable
\end{lstlisting}
Ein 3-dimensionaler Vektor. Repräsentiert üblicherweise Raumkoordinaten.\\


\subsection*{Vector4}
\begin{lstlisting}
class Vector4
\end{lstlisting}
Ein 4-dimensionaler Vektor für homogene Koordinaten. Instanzen dieser Klasse werden benötigt, wenn zwischen 3D-Perspektiven umgerechnet werden soll.\\



\subsection*{JoglEarth}
\begin{lstlisting}
final class JoglEarth
\end{lstlisting}
Diese Klasse stellt die \textit{Main} Methode bereit.\\




\chapter{Sequenzdiagramme}

\section{Laden einer lokal noch nicht vorhandenen Kachel}
In diesem Sequenzdiagramm wird dargestellt, wie die Anfrage nach einer Texturkachel über die verschiedenen Cacheebenen propagiert und schließlich asynchron beantwortet wird.\\


\begin{figure}
\begin{centering}
\includegraphics[scale=0.57,angle=90,origin=c]{Ablaufdiagramm.eps}
\caption{Laden einer lokal noch nicht vorhandenen Kachel}
\end{centering}
\end{figure}



\chapter{Beschreibung der Interfaces}

\section{Package Model}

\subsection*{RequestListener}

\section{Package View}

\section{Package Controller}

\subsection*{UpdateListener}




\chapter{Beschreibung der Enumerations}

\section{Package Model}

\subsection*{NominatimQuery.Type}

\section{Package View}

\section{Package Controller}

\subsection*{TileType}
\subsection*{PoiType}
\subsection*{Camera.Type}

\chapter{Designpatterns}
\section{Adapter Pattern}
Das \textit{Adapter Pattern} ist ein Strukturmuster. \\
Es dient zur Übersetzung einer Schnittstelle in eine andere. \\ Dieses Pattern findet Anwendung bei den \textit{Mouse- und Key"-listenern}, welche in der Benutzeroberfläche implementiert werden. \\ Ziel ist es den Quellcode übersichtlich zu halten. Aus diesem Grund werden nur die benötigten Methoden der Listener überschrieben. Alle nicht erforderlichen Methoden werden ignoriert.

\section{Chain of Responsibility Pattern}
Das \textit{Chain of Responsibility Pattern} (bzw. Zuständigkeitskette) ist ein Verhaltensmuster. \\
Hierbei werden mehrere Objekte hintereinander verkettet um gemeinsam eine eingehende Anfrage bearbeiten zu können. Dafür wird eine Anfrage entlang der Kette durchgereicht, bis ein Objekt die Anfrage beantworten kann. \\ Es findet Anwendung beim Speichermanagement. Eine Anfrage für eine benötigte Ressource wird immer an den \textit{memoryCache} gestellt. Die Anfrage wird entsprechend der Kette (siehe Abbildung) durchgereicht bis sie bearbeitet werden kann. \\ Ziel ist  die Entkopplung des Auslösers einer Anfrage mit seinem Empfänger.

\section{Data Transfer Object}
Das \textit{Data Transfer Object} ist ein Muster für objektrelationale Abbildung. \\
Hierbei werden mehrere Daten gebündelt als ein Objekt übertragen. \\ Es findet Anwendung bei Suchergebnissen und der Anfrage nach POIs. Alle Datensätze werden dann gebündelt übergeben und nicht jede Information seperat. \\ Ziel ist es die Daten zu strukturieren bzw. vollständig gruppierte Information zu einer Anfrage zu erhalten.

\section{Iterator Pattern}
Das \textit{Iterator Pattern} ist ein Verhaltensmuster. \\ Hierbei wird die verwendete Datenstruktur elementweise durchlaufen, ohne deren interne Anordnung preiszugeben.\\ Es findet Anwendung ... \\ Ziel ist es die eingesetzten Datenstrukturen effizient zu durchsuchen.

\newpage
\section{Mediator Pattern}
Das \textit{Mediator Pattern} ist ein Verhaltensmuster. \\ Hierbei fungiert der Vermittler als Kommunikationsschnittstelle zwischen Objekten in einem komplexen System. \\ Es findet mehrfache Anwendung im gesamten Programm, wie beispielsweise beim Speichermanagement, beim Rendering, usw. \\ Ziel ist lockere Kopplung. Es sollen nicht alle Objekt voneinander Kenntnis besitzen.

\section{Model-View-Controller (MVC) Pattern}
Das \textit{Model-View-Controller Pattern} ist ein Architekturmuster. \\
\begin{figure}[ht]
\begin{centering}
\includegraphics[scale=0.5]{ModelViewController.eps}
\caption{Das Model-View-Controller Pattern}
\end{centering}
\end{figure}



\section{Multiton Pattern}
Das \textit{Multiton Pattern} ist ein Erzeugungsmuster. \\ Hierbei wird sichergestellt, dass mehrere Instanzen eines Objekts existieren dürfen. Eine eindeutige Zuordnung wird geregelt durch Vergabe eines Schlüssels. \\ Es findet Anwendung bei den \textit{RequestListenern} ???? \\ Ziel ist parallele Anfragestellung und -beantwortung.

\section{Observer Pattern}
Das \textit{Observer Pattern} ist ein Verhaltensmuster. \\ Hierbei wird eine Info bei durchgeführten Änderungen am Objekt an alle abhängigen Komponenten weitergegeben. \\ Es findet Anwendung ... jede Menge Observer \\ Ziel ist lose Kopplung und zudem werden die abhängigen Objekte automatisch über Änderungen in Kenntnis gesetzt.

\section{Singleton Pattern}
Das \textit{Singleton Pattern} ist ein Erzeugungsmuster. \\ Hierbei wird sichergestellt, dass genau eine einzige Instanz eines Objekts existiert. \\ Es findet Anwendung bei der Benutzeroberfläche, von der nur eine Instanz existieren darf. \\ Ziel ist eine sichergestellte Zugriffskontrolle auf das Objekt. 




\chapter{Qualitätsmerkmale}
\section{Entwurfsqualität}
Bei der Qualität des Entwurfs beziehen wir uns auf \textit{Robert Cecil Martins} Merkmalsdefinitionen \footnote{Robert Cecil Martin (2002). Agile Software Development: Principles, Patterns and Practices. Pearson Education.} die im Folgenden erläutert werden.

\subsection*{Anzahl an Klassen und Interfaces}
Die Anzahl aller Klassen inklusive abstrakter Klassen (sowie Interfaces) im gesamten Paket. Es dient als aussagekräftiger Indikator für die Erweiterbarkeit eines Pakets.

\subsection*{Afferente Kopplung}
Die Abhängigkeit anderer Pakete von einem Paket ist ein Maß für dessen Verantwortlichkeiten und dessen Einfluss.

\subsection*{Efferente Kopplung}
Die Abhängigkeit eines Pakets von anderen Paketen ist ein Maß für die Unselbstständigkeit dieses Pakets.

\subsection*{Abstraktheit}
Der Anteil abstrakter Klassen (sowie Interfaces) an allen Klassen im Paket ist ein Indikator für die Abstraktheit eines Pakets.

\subsection*{Stabilität}
Das Verhältnis von afferenter Kopplung zur gesamten Kopplung gibt Auskunft über die Resilienz gegenüber Änderungen eines Pakets.

\subsection*{Balance von Abstraktion und Abhängigkeit}
Der Abstraktionsgrad der Klassen sollte in etwa deren Unabhängigkeit von anderen Klassen entsprechen. Bei Erfüllung der Anforderung spricht man von optimaler Balance.

\subsection*{Kohäsion}
Als Ergänzung zu Martin's Definitionen, welche sich nur auf das Zusammenspiel zwischen den Paketen bezieht, wird zudem die Kohäsion berücksichtigt.\\

Kohäsion ist der Versuch, zusammenhängende Programmstrukturen in einer Klasse zusammenzuführen, um z.B. nachträgliche Änderungen auf lokale Anpassungen des Codes zu beschränken.


\section{Gütekriterien nach ISO/IEC 9126}
\subsection*{Funktionalität}
Funktionalität beinhaltet Angemessenheit, Richtigkeit, Interoperabilität, Ordnungsmäßigkeit und Sicherheit.

\subsection*{Zuverlässigkeit}
Eine Menge von Merkmalen, die sich auf die Fähigkeit einer Software/eines Systems beziehen, ihr/sein Leistungsniveau unter festgelegten Bedingungen über einen festgelegten Zeitraum oder über eine festgelegte Anzahl von Transaktionen zu bewahren. [ISO 9126]

\subsection*{Benutzbarkeit}
Die Fähigkeit eines Softwareprodukts, unter spezifizierten Bedingungen für einen Benutzer verständlich, erlernbar, anwendbar und attraktiv zu sein. [ISO 9126]

\subsection*{Effizienz}
(1) Die Fähigkeit eines Softwareprodukts, unter festgelegten Bedingungen eine angemessene Leistung zu erbringen, bezogen auf den Umfang der eingesetzten Betriebsmittel. [ISO 9126]

\subsection*{Änderbarkeit}
Mit Änderbarkeit bezeichnet man den Aufwand, der zur Durchführung bestimmter Änderungen notwendig ist. Änderungen können Korrekturen, Verbesserungen oder Anpassungen an Änderungen der Umgebung, der Anforderungen und der funktionalen Spezifikation einschließen. [ISO 9126]

\subsection*{Portabilität}
Portabilität oder Übertragbarkeit ist die Eignung einer Software, von einer Umgebung in eine andere übertragen zu werden. Diese Umgebung kann die organisatorische Umgebung, Hardware- oder Software-Umgebung einschließen. [ISO 9126]


\end {document}